<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>swift on VietHQ - Tìm đơn giản trong phức tạp</title>
    <link>https://gg4acrossover.github.io/hugosite/categories/swift/</link>
    <description>Recent content in swift on VietHQ - Tìm đơn giản trong phức tạp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 21 Oct 2019 02:13:23 +0700</lastBuildDate>
    
	<atom:link href="https://gg4acrossover.github.io/hugosite/categories/swift/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Decorator và thực tiễn áp dụng</title>
      <link>https://gg4acrossover.github.io/hugosite/post/decorator-va-thuc-tien-ap-dung/</link>
      <pubDate>Mon, 21 Oct 2019 02:13:23 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/decorator-va-thuc-tien-ap-dung/</guid>
      <description>Chào mọi người, hôm nay mình sẽ giới thiệu về một pattern khá phổ biến - decorator . Nói một cách vắn tắt, đây là pattern thuộc nhóm cấu trúc và sử dụng composition để tạo ra đối tượng ta mong muốn một cách linh hoạt. Nghe có vẻ hơi&amp;hellip;lý thuyết, nhưng mình sẽ đi ngay vào phần tình huống và cách thức giải quyết dựa vào decorator để các bạn dễ dàng hình dung hơn.</description>
    </item>
    
    <item>
      <title>Lấy url từ string</title>
      <link>https://gg4acrossover.github.io/hugosite/post/get-urls-from-string/</link>
      <pubDate>Thu, 11 Jul 2019 11:08:05 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/get-urls-from-string/</guid>
      <description>Từ một lời thắc mắc Bạn đã bao giờ tự hỏi làm thế nào để lấy ra url từ string ko? Cách đơn giản hướng đến đầu tiên là split string ra rồi đưa vào hàm URL.init
var str = &amp;quot;goto https://www.google.com/&amp;quot; let urls = str.components(separatedBy: .whitespaces) .compactMap(URL.init) // [goto, https://www.google.com/]  Kết quả ra cả &amp;ldquo;goto&amp;rdquo;, có gì đó sai sai? Hóa ra thằng URL.init vốn dễ dãi. Nó nhận cả đường dẫn, tên thư mục nó lấy, url nó lấy, tên folder nó lấy, blah blah.</description>
    </item>
    
    <item>
      <title>Ẩn Keyboard</title>
      <link>https://gg4acrossover.github.io/hugosite/post/dismiss-keyboard/</link>
      <pubDate>Tue, 18 Jun 2019 13:59:48 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/dismiss-keyboard/</guid>
      <description>Xin chào mọi người, hôm nay mình sẽ trở lại với một vấn đề quen thuộc. Đó là ẩn keyboard, xử lý tuy rằng đơn giản, nhưng để làm &amp;ldquo;mượt&amp;rdquo; thì cũng không dễ tẹo nào. Mình sẽ đi từng bước một, từ cách bình dân nhất, rồi đến những xử lý refactor.
Cách bình dân Cách chúng ta thường thấy nhất là:
class ViewController: UIViewController { @IBOutlet weak var txtField: UITextField!</description>
    </item>
    
    <item>
      <title>Collection view layout</title>
      <link>https://gg4acrossover.github.io/hugosite/post/collectionview_layout/</link>
      <pubDate>Mon, 10 Jun 2019 10:40:29 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/collectionview_layout/</guid>
      <description>CollectionView hoạt động như nào UICollectionView là subclass của UIScrollView. Nói một cách khác, nó là UIView nhưng có thêm chức năng thay đổi bounds. Khi chúng ta di chuyển cell, chúng ta thay đổi giá trị contentOffset, đồng thời thay đổi không gian hiển thị của UICollectionView.
Trăm nghe không bằng một thấy, tốt nhất là trình diễn bằng hình ảnh cho dễ hiểu.
Trên là hình ảnh mắt chúng ta nhìn thấy khi di chuyển collection view (ô chữ nhật xanh lá cây tượng trưng cho màn hình điện thoại).</description>
    </item>
    
    <item>
      <title>Vài tip 03.06.19</title>
      <link>https://gg4acrossover.github.io/hugosite/post/new-tip-03-06-19/</link>
      <pubDate>Mon, 03 Jun 2019 14:10:45 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/new-tip-03-06-19/</guid>
      <description>Một số phương thức hỗ trợ lập trình, note lại cho bản thân.
Autolayout extension UIView { func pinToBounds(_ view: UIView) { view.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ view.topAnchor.constraint(equalTo: topAnchor), view.bottomAnchor.constraint(equalTo: bottomAnchor), view.leadingAnchor.constraint(equalTo: leadingAnchor), view.trailingAnchor.constraint(equalTo: trailingAnchor) ]) } }  Storyboard protocol Storyboardable { } extension Storyboardable where Self: UIViewController { static func instantiateInitialFromStoryboard() -&amp;gt; Self { let controller = storyboard().instantiateInitialViewController() return controller! as! Self } static func storyboard(fileName: String? = nil) -&amp;gt; UIStoryboard { let storyboard = UIStoryboard(name: fileName ?</description>
    </item>
    
    <item>
      <title>Tip iOS cho tháng năm</title>
      <link>https://gg4acrossover.github.io/hugosite/post/mot-vai-tip-thang-5-2019/</link>
      <pubDate>Thu, 23 May 2019 10:09:24 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/mot-vai-tip-thang-5-2019/</guid>
      <description>CSS string Nếu ta muốn sử dụng style có sẵn trên web thì có thể nghiên cứu phương án tận dụng nó lại trên iOS.
Bước đầu implement phương thức gắn css style vào string
extension NSAttributedString { convenience public init(text: String, styles: [String: String]) { let style = styles.compactMap { (key, value) -&amp;gt; String in return &amp;quot;\(key): \(value)&amp;quot; }.joined(separator: &amp;quot;;&amp;quot;) try! self.init( data: Data(&amp;quot;&amp;lt;p style=\&amp;quot;\(style)\&amp;quot;&amp;gt;\(text)&amp;lt;/p&amp;gt;&amp;quot;.utf8), options: [.documentType: NSAttributedString.DocumentType.html, .</description>
    </item>
    
    <item>
      <title>Làm việc với response</title>
      <link>https://gg4acrossover.github.io/hugosite/post/lam-viec-voi-response/</link>
      <pubDate>Wed, 20 Mar 2019 16:33:59 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/lam-viec-voi-response/</guid>
      <description>Bài toán Khi nhận response từ server, chúng ta thường thấy json có điểm chung như sau
struct Response { let timestamp: String let id: Int let payload: Any }  timestamp và id là những trường mặc định luôn được trả về, chúng có type cố định. Còn type của payload lại phụ thuộc vào api bạn call, thế nên mình đang để dưới dạng Any.
Tuy nhiên sử dụng type Any có nhiều hạn chế: chúng ta phải biết chính xác nó-là-gì để ép kiểu trước khi sử dụng.</description>
    </item>
    
  </channel>
</rss>