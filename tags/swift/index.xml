<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>swift on VietHQ - Tìm đơn giản trong phức tạp</title>
    <link>https://gg4acrossover.github.io/hugosite/tags/swift/</link>
    <description>Recent content in swift on VietHQ - Tìm đơn giản trong phức tạp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 03 Jun 2019 14:10:45 +0700</lastBuildDate>
    
	<atom:link href="https://gg4acrossover.github.io/hugosite/tags/swift/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Vài tip 03.06.19</title>
      <link>https://gg4acrossover.github.io/hugosite/post/new-tip-03-06-19/</link>
      <pubDate>Mon, 03 Jun 2019 14:10:45 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/new-tip-03-06-19/</guid>
      <description>Một số phương thức hỗ trợ lập trình, note lại cho bản thân.
Autolayout extension UIView { func pinToBounds(_ view: UIView) { view.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ view.topAnchor.constraint(equalTo: topAnchor), view.bottomAnchor.constraint(equalTo: bottomAnchor), view.leadingAnchor.constraint(equalTo: leadingAnchor), view.trailingAnchor.constraint(equalTo: trailingAnchor) ]) } }  Storyboard protocol Storyboardable { } extension Storyboardable where Self: UIViewController { static func instantiateInitialFromStoryboard() -&amp;gt; Self { let controller = storyboard().instantiateInitialViewController() return controller! as! Self } static func storyboard(fileName: String? = nil) -&amp;gt; UIStoryboard { let storyboard = UIStoryboard(name: fileName ?</description>
    </item>
    
    <item>
      <title>Tip iOS cho tháng năm</title>
      <link>https://gg4acrossover.github.io/hugosite/post/mot-vai-tip-thang-5-2019/</link>
      <pubDate>Thu, 23 May 2019 10:09:24 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/mot-vai-tip-thang-5-2019/</guid>
      <description>CSS string Nếu ta muốn sử dụng style có sẵn trên web thì có thể nghiên cứu phương án tận dụng nó lại trên iOS.
Bước đầu implement phương thức gắn css style vào string
extension NSAttributedString { convenience public init(text: String, styles: [String: String]) { let style = styles.compactMap { (key, value) -&amp;gt; String in return &amp;quot;\(key): \(value)&amp;quot; }.joined(separator: &amp;quot;;&amp;quot;) try! self.init( data: Data(&amp;quot;&amp;lt;p style=\&amp;quot;\(style)\&amp;quot;&amp;gt;\(text)&amp;lt;/p&amp;gt;&amp;quot;.utf8), options: [.documentType: NSAttributedString.DocumentType.html, .</description>
    </item>
    
    <item>
      <title>Ôn tập iOS</title>
      <link>https://gg4acrossover.github.io/hugosite/post/on-tap-ios/</link>
      <pubDate>Mon, 20 May 2019 02:21:43 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/on-tap-ios/</guid>
      <description>Một số câu hỏi ôn tập iOS Begin Câu 1 struct Question { var level: Int = 1 } var question1 = Question() var question2 = question1 question2.level = 2  Giá trị của question1.level sẽ như nào? Nếu Question là class thì có gì khác không? Tại sao?
Câu 2 var view1 = UIView() view1.alpha = 0.5 let view2 = UIView() view2.alpha = 0.5 // compile error?  Dòng code view2.</description>
    </item>
    
    <item>
      <title>Codable remake part 1</title>
      <link>https://gg4acrossover.github.io/hugosite/post/codable-remake-part-1/</link>
      <pubDate>Fri, 26 Apr 2019 10:46:46 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/codable-remake-part-1/</guid>
      <description>Dạo này mình hơi bận nên bỏ bê blog quá. Hôm nay quyết định chăm chút trở lại bằng một series về Codable, coi như làm nóng bản thân :D. Đã có một bài mình đề cập đến vấn đề này. Tuy nhiên bài viết đó chỉ ở mức giới thiệu, lần này mình sẽ tăng độ khó cho game thêm chút nữa.
Codable let json = &amp;quot;&amp;quot;&amp;quot; { &amp;quot;userName&amp;quot;: &amp;quot;crossover&amp;quot;, &amp;quot;position&amp;quot;: &amp;quot;SG&amp;quot;, &amp;quot;id&amp;quot;: 234 } &amp;quot;&amp;quot;&amp;quot;.</description>
    </item>
    
    <item>
      <title>Nếu thì và những cách thay thế</title>
      <link>https://gg4acrossover.github.io/hugosite/post/if-else-and-another/</link>
      <pubDate>Wed, 19 Dec 2018 13:58:26 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/if-else-and-another/</guid>
      <description>Bạn có biết rằng trên thế giới có một cộng đồng anti if, else. Trên đường đi tìm đường cách mệnh, coi như cũng tạo chút thử thách cho bản thân, mình đã tìm ra một số phương pháp tương đối hữu ích.
1. Thủ thuật refactor Các phương pháp này có thể coi như là trick để code trông gọn hơn, đồng thời loại bỏ if.
Dictionary Đây là phương pháp mình sử dụng từ lâu.</description>
    </item>
    
    <item>
      <title>Make swift great again</title>
      <link>https://gg4acrossover.github.io/hugosite/post/make-swift-great-again/</link>
      <pubDate>Tue, 11 Dec 2018 17:39:09 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/make-swift-great-again/</guid>
      <description>Làm swift toẹt vời trở lại Dạo này thời tiết Hà Nội trở lạnh, post một bài cho nóng người :D. Lần này mình sẽ trình bày về một số tip để làm code trông swifty hơn.
defer Sử dụng defer nếu như bạn là người hay quên :D. Tác dụng của defer là nó sẽ chạy sau khi hàm return.
 var x = 1 func doDefer(_ value: inout Int) -&amp;gt; Int { // effect after return defer { value += 1 } value += 1 return value } print(doDefer(&amp;amp;x)) // 2 print(x) // 3  Với tác dụng của hàm defer ta có thể tận dụng để giải phóng bộ nhớ, close file hay bất cứ tác vụ nào đòi hỏi 2 bước ràng buộc lúc bắt đầu và kết thúc.</description>
    </item>
    
    <item>
      <title>Config Project</title>
      <link>https://gg4acrossover.github.io/hugosite/post/config-project/</link>
      <pubDate>Fri, 30 Nov 2018 14:33:34 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/config-project/</guid>
      <description>Hồi mới tiếp xúc với lập trình IOS, mỗi khi build sản phẩm để công ty test, mình lại phải điều chỉnh một số configuration ngay chính trong code. Lúc config thế này, lúc config thế kia, tùy chỉnh cho nó hợp với môi trường theo cách #define như này
#ifdef DEBUG #define BASE_URL ... #else #define BASE_URL ... #endif  hoặc kiểu comment như này
// Product // static NSString* kBaseURL .</description>
    </item>
    
    <item>
      <title>Tạo view từ xib</title>
      <link>https://gg4acrossover.github.io/hugosite/post/tao-view-tu-xib/</link>
      <pubDate>Tue, 20 Nov 2018 16:50:01 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/tao-view-tu-xib/</guid>
      <description>1. Tạo uiview từ xib Khi tạo giao diện cho 1 app, chắc hẳn ai cũng gặp trường hợp có các view con xuất hiện đi, xuất hiện lại giữa các màn hình khác nhau. Để tránh việc copy qua lại nhàm chán, ta nên tách view con đó ra thành 1 xib duy nhất và tái sử dụng khi cần thiết.
Đầu tiên ta tạo class kế thừa từ UIView và Xib đi kèm như hình sau.</description>
    </item>
    
    <item>
      <title>Clickable label</title>
      <link>https://gg4acrossover.github.io/hugosite/post/clickable-label/</link>
      <pubDate>Fri, 09 Nov 2018 14:29:29 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/clickable-label/</guid>
      <description>Để tạo clickable cho text, ta có thể sử dụng UITextView, đó là cách đơn giản nhất. Ngoài ra ta cũng có thể tận dụng sức mạnh của Textkit :D để áp dụng trực tiếp lên UILabel mặc dù chỉ sử dụng một phần rất nhỏ của nó thôi.
Hôm nay lười nên mình show code luôn :), extension của UILabel nhé :).
Cách sử dụng đơn giản như sau</description>
    </item>
    
    <item>
      <title>Toán tử 3 ngôi  hay sugar syntax</title>
      <link>https://gg4acrossover.github.io/hugosite/post/toan-tu-3-ngoi-hay-syntax-sugar/</link>
      <pubDate>Tue, 06 Nov 2018 09:36:44 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/toan-tu-3-ngoi-hay-syntax-sugar/</guid>
      <description>Tình huống Hôm nay có chút buồn ngủ nên mình tạo động lực cho bản thân bằng cách tự làm thử toán tử ba ngôi trong swift. Đôi khi chơi theo kiểu hardcore cũng mang lại liều doping khá mạnh, giống như phê thuốc vầy :D.
Bình thường mình không dùng autoclosure vì thấy nó cũng không có gì đặc sắc, chỉ là syntax sugar. Áp dụng đúng chỗ thì ngon, áp dụng không đúng chỗ thì càng làm code khó hiểu.</description>
    </item>
    
    <item>
      <title>Tạo Style cho UIView</title>
      <link>https://gg4acrossover.github.io/hugosite/post/style-view-2/</link>
      <pubDate>Fri, 02 Nov 2018 15:05:09 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/style-view-2/</guid>
      <description>Giới thiệu Có nhiều cách để làm đẹp hơn là làm bánh hay làm tình
Đây là phần 2 của bài trước tuy nhiên nó chẳng liên quan gì đến phần đầu cả :D. Ở phần đầu tiên mình đã giới thiệu một cách đơn giản để ta reuse lại code sử dụng struct. Phần này phức tạp hơn, ý tưởng dựa trên việc sử dụng IBInspectable để định hìnhh style cho UIView, bạn vừa có thể tự tạo style trong code, đồng thời cũng có thể tùy biến thông qua UI.</description>
    </item>
    
    <item>
      <title>Style view</title>
      <link>https://gg4acrossover.github.io/hugosite/post/style-view/</link>
      <pubDate>Sun, 30 Sep 2018 01:27:11 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/style-view/</guid>
      <description>Một phút cho quảng cáo Trong lập trình IOS nói riêng và mobile nói chung, kỹ năng code giao diện là phần rất quan trọng. Độ phức tạp của một task và thời gian thực hiện phụ thuộc nhiều vào UI bạn làm. UI đơn giản thì làm nhanh, UI khó thì làm lâu. Kĩ năng tạo giao diện cần được các thợ code mobile trau dồi, rèn luyện thật kĩ.</description>
    </item>
    
    <item>
      <title>Xử lý callback hell với functional programming</title>
      <link>https://gg4acrossover.github.io/hugosite/post/xu-ly-callback-hell/</link>
      <pubDate>Wed, 19 Sep 2018 00:28:59 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/xu-ly-callback-hell/</guid>
      <description>Giới thiệu Callback là kĩ thuật được ưa chuộng trong lập trình hiện nay. Ngặt nỗi, nếu sử dụng không khéo rất dễ xảy ra callback hell. Dưới con mắt nghệ thuật, nó lai lái kim tự tháp, nhưng dưới con mắt coder, đặc biệt với những lập trình viên ưa-cái-đẹp thì nó chẳng khác gì một thảm họa. Bí kíp tránh callback hell không phải là không có. Nếu chính đạo dùng Promise thì tà đạo chơi functional programming.</description>
    </item>
    
    <item>
      <title>Method dispath trong protocol</title>
      <link>https://gg4acrossover.github.io/hugosite/post/method-dispatch/</link>
      <pubDate>Sat, 25 Nov 2017 11:36:01 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/method-dispatch/</guid>
      <description>Method dispatch là gì? Method dispatch là thuật toán xác định cách thức vận hành method thông qua compiler. Nhắc đến method dispatch, thường người ta sẽ nói đến 2 kiểu điển hình:
 Static dispatch: xác định hàm được chạy trong quá trình biên dịch. Dynamic dispatch: xác định hàm được chạy trong quá trình runtime, cái này thể hiện rõ nhất qua tính đa hình trong OOP.  Với mỗi ngôn ngữ, tùy thuộc vào thiết kế mà có sự khác nhau về cách thức vận hành phương thức.</description>
    </item>
    
    <item>
      <title>Codable swift 4</title>
      <link>https://gg4acrossover.github.io/hugosite/post/codable-swift4/</link>
      <pubDate>Sat, 18 Nov 2017 10:10:10 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/codable-swift4/</guid>
      <description>Codable là gì? Chắc hẳn ở swift 3 đa số chúng ta sử dụng lib ObjectMapper để parse json thành model. Thư viện này khá tiện dụng, tuy nhiên có một nhược điểm là chúng ta vẫn phải viết hàm map key. Điều này mình không thích lắm, trước đây objc có JSONModel parse thông minh hơn hẳn, ai dùng qua chắc đều biết. Đáng tiếc là ở swift không có thằng nào như vầy cả.</description>
    </item>
    
    <item>
      <title>Date là gì, có ăn được không?</title>
      <link>https://gg4acrossover.github.io/hugosite/post/date-la-gi/</link>
      <pubDate>Mon, 06 Nov 2017 16:50:29 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/date-la-gi/</guid>
      <description>Date Date là một đối tượng gần như không thể thiếu trong các app hiện nay. Nó xuất hiện trong lịch, trong thương mại điện tử, trong các app nhắc việc. Làm việc với date tưởng chừng như đơn giản nhưng lại là vấn đề hết sức đau đầu vì nó mang tính tương đối :D. Tỉ như ở Việt Nam, người dân đang vội vã đón con cuối chiều, nhưng ở nước khác, họ lại đang cafe buổi sáng.</description>
    </item>
    
    <item>
      <title>Enum result</title>
      <link>https://gg4acrossover.github.io/hugosite/post/enum-swift/</link>
      <pubDate>Sat, 14 Oct 2017 10:34:47 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/enum-swift/</guid>
      <description>Giới thiệu Có nhiều cách để viết Enum hơn là làm bánh hay làm tình. Ở bài viết này mình sẽ trình bày một hướng đi, hi vọng mọi người sẽ like :D
Kiểu phổ thông Chắc hẳn chúng ta thấy kiểu viết enum này rất quen thuộc, đặc biệt là đối với những ai dùng alamofire
enum Result&amp;lt;T&amp;gt; { case success(T) case failure(Error) public var value: T? { switch self { case .</description>
    </item>
    
    <item>
      <title>Tạo APIClient với swift 3</title>
      <link>https://gg4acrossover.github.io/hugosite/post/tao-api-client-swift-3/</link>
      <pubDate>Mon, 29 May 2017 15:11:07 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/tao-api-client-swift-3/</guid>
      <description>1. Giới thiệu Từ hồi mới bắt đầu làm IOS, thằng nào cũng hỏi mình có biết sử dụng AFNetworking không? Khổ nỗi lúc đó, mình mới chuyển từ làm game sang, rất ít dùng đến lib, đa số tự viết nên lơ tơ mơ không biết chúng nó nói đến cái gì. Dùng anh google tìm hiểu thì mình mới ngộ ra AFNetworking là một tool wrap lại urlsession, hỗ trợ developer thao tác nhanh gọn, đỡ mất công viết đi viết lại những đoạn code thủ tục (lib đã hỗ trợ bạn làm việc đó).</description>
    </item>
    
    <item>
      <title>Tạo progressHUD đơn giản</title>
      <link>https://gg4acrossover.github.io/hugosite/post/progress-hud-don-gian/</link>
      <pubDate>Wed, 10 May 2017 11:25:40 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/progress-hud-don-gian/</guid>
      <description>Giới thiệu ProgressHUD là thành phần không thể thiếu trong các app mobile, thường được sử dụng mỗi khi load data từ server. Mình hay dùng tool hỗ trợ, tỉ như thằng SVProgressHUD hay thằng MBProgressHUD. Tuy nhiên thi thoảng tự sướng chút cho nó yomost 😄. Ví dụ này mình sẽ viết bằng swift 3
Ý tưởng Mình sẽ tạo 1 window với rootViewController có nhiệm vụ làm container cho thằng HUD.</description>
    </item>
    
    <item>
      <title>Tạo function trong swift</title>
      <link>https://gg4acrossover.github.io/hugosite/post/tao-func-trong-swift/</link>
      <pubDate>Mon, 05 Sep 2016 16:27:24 +0700</pubDate>
      
      <guid>https://gg4acrossover.github.io/hugosite/post/tao-func-trong-swift/</guid>
      <description>Có nhiều cách để tạo func hơn là làm bánh hay làm tình ( chế từ câu nói của Nguyễn Miền Biên Thùy).
Tạo function 1 param func sayHello(name: String) -&amp;gt; String { return &amp;quot;Hello &amp;quot; + name + &amp;quot;!&amp;quot; } print( sayHello(&amp;quot;Peter&amp;quot;)) // Hello Perter!  Func có nhiều hơn 1 param func sayHelloAgain(name : String, anotherName: String) -&amp;gt; String { return &amp;quot;Hello &amp;quot; + name + &amp;quot;, &amp;quot; + anotherName } print( sayHelloAgain(&amp;quot;Peter&amp;quot;, anotherName: &amp;quot;Tom&amp;quot;)) // Hello Peter, Tom  ở param thứ 2 ta phải viết thêm cái tên biến ở đằng trước.</description>
    </item>
    
  </channel>
</rss>